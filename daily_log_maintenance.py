#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ============================================================================
# МОДУЛЬ ЕЖЕДНЕВНОГО ОБСЛУЖИВАНИЯ СИСТЕМЫ ЛОГИРОВАНИЯ
# ============================================================================
# 
# Этот модуль обеспечивает автоматическое обслуживание системы логирования
# приложения Image Hosting. Выполняет критически важные задачи по управлению
# жизненным циклом логов, предотвращению переполнения диска и оптимизации
# производительности системы логирования.
# 
# Основные функции:
# - Автоматическая архивация устаревших логов (старше 30 дней)
# - Удаление старых архивов для экономии дискового пространства (старше 12 месяцев)
# - Очистка временных файлов логирования
# - Сбор и отображение статистики использования логов
# - Мониторинг состояния системы логирования
# 
#=============================================
#
#Скрипт для ежедневного обслуживания логов:
# - Архивация логов старше 30 дней
# - Удаление архивов старше 12 месяцев
# - Очистка временных файлов
#
# Для автоматического запуска добавьте в crontab:
# 0 2 * * * /usr/bin/python3 /path/to/daily_log_maintenance.py
#
#Для Windows Task Scheduler:
#Запускать ежедневно в 02:00
#
#=============================================
# Автоматизация:
# 
# Linux/Unix (crontab):
#   0 2 * * * /usr/bin/python3 /path/to/daily_log_maintenance.py
# 
# Windows (Task Scheduler):
#   Запускать ежедневно в 02:00 AM
#   Программа: python.exe
#   Аргументы: daily_log_maintenance.py
#   Рабочая папка: путь к проекту
# 
# Использование:
#   python daily_log_maintenance.py        # Выполнить обслуживание
#   python daily_log_maintenance.py stats  # Показать статистику логов
# 
# Безопасность:
# - Создает резервные копии перед архивацией
# - Логирует все операции для аудита
# - Обрабатывает ошибки без прерывания работы приложения
# - Проверяет доступность файлов перед операциями
# 
# ============================================================================

# ============================================================================
# ИМПОРТ НЕОБХОДИМЫХ МОДУЛЕЙ
# ============================================================================

import os        # Операции с файловой системой и путями
import sys       # Системные функции и управление путями импорта
import logging   # Система логирования для отчетности обслуживания
from datetime import datetime  # Работа с датами для архивации

# Добавляем текущую директорию в путь для импорта локальных модулей
# Это обеспечивает корректную работу при запуске из разных директорий
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Импортируем специализированные функции логирования из нашего модуля
from logging_config import setup_monthly_archive, cleanup_old_archives

# ============================================================================
# ОСНОВНАЯ ФУНКЦИЯ ОБСЛУЖИВАНИЯ ЛОГОВ
# ============================================================================

def main():
    """
    Основная функция для выполнения ежедневного обслуживания системы логирования.
    
    Эта функция координирует все аспекты обслуживания логов, включая архивацию,
    очистку и мониторинг. Обеспечивает надежное выполнение всех операций
    с полным логированием процесса для аудита и диагностики.
    
    Последовательность операций:
    1. Настройка специализированного логирования для процесса обслуживания
    2. Архивация устаревших активных логов
    3. Удаление старых архивов для экономии места
    4. Очистка временных файлов логирования
    5. Генерация отчета о выполненных операциях
    
    Логирование:
    - Создает отдельный лог файл maintenance.log для отслеживания операций
    - Дублирует вывод в консоль для интерактивного мониторинга
    - Использует структурированный формат с временными метками
    - Логирует все этапы процесса для полной прозрачности
    
    Error Handling:
    - Обрабатывает все исключения без прерывания работы основного приложения
    - Логирует детальную информацию об ошибках
    - Возвращает соответствующие коды выхода для автоматизации
    - Продолжает выполнение при частичных ошибках
    
    Exit Codes:
    - 0: Успешное завершение всех операций обслуживания
    - 1: Критическая ошибка, требующая вмешательства администратора
    
    Performance Considerations:
    - Выполняется в низкоприоритетном режиме для минимального влияния на приложение
    - Оптимизирован для работы в периоды низкой активности (обычно ночью)
    - Использует эффективные алгоритмы сжатия для архивации
    """
    
    # ========================================================================
    # НАСТРОЙКА СИСТЕМЫ ЛОГИРОВАНИЯ ДЛЯ ПРОЦЕССА ОБСЛУЖИВАНИЯ
    # ========================================================================
    
    # Создаем специализированный форматтер для логов обслуживания
    # Включает временные метки и уровни важности для детального отслеживания
    log_formatter = logging.Formatter(
        '[%(asctime)s] %(levelname)s: %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # Настраиваем файловый обработчик для сохранения истории обслуживания
    # Использует UTF-8 кодировку для корректного отображения русских сообщений
    maintenance_handler = logging.FileHandler('logs/maintenance.log', encoding='utf-8')
    maintenance_handler.setFormatter(log_formatter)
    
    # Создаем специализированный логгер для операций обслуживания
    # Отделен от основного логгера приложения для избежания конфликтов
    logger = logging.getLogger('maintenance')
    logger.setLevel(logging.INFO)
    logger.addHandler(maintenance_handler)
    
    # Добавляем консольный вывод для интерактивного мониторинга
    # Полезно при ручном запуске или отладке процесса обслуживания
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(log_formatter)
    logger.addHandler(console_handler)
    
    # Начинаем процесс обслуживания с записи в лог
    logger.info('Starting daily log maintenance')
    
    try:
        # ====================================================================
        # ЭТАП 1: АРХИВАЦИЯ УСТАРЕВШИХ ЛОГОВ
        # ====================================================================
        
        # Архивируем активные логи, которые превысили лимит возраста
        # Это освобождает место и улучшает производительность чтения логов
        logger.info('Starting log archiving process')
        setup_monthly_archive()
        logger.info('Log archiving completed')
        
        # ====================================================================
        # ЭТАП 2: УДАЛЕНИЕ СТАРЫХ АРХИВОВ
        # ====================================================================
        
        # Удаляем архивы, которые превысили срок хранения
        # Предотвращает неконтролируемый рост использования дискового пространства
        logger.info('Starting old archive cleanup')
        cleanup_old_archives()
        logger.info('Old archive cleanup completed')
        
        # ====================================================================
        # ЭТАП 3: ОЧИСТКА ВРЕМЕННЫХ ФАЙЛОВ
        # ====================================================================
        
        # Удаляем временные файлы, созданные в процессе логирования
        # Включает lock-файлы, временные копии и поврежденные файлы
        cleanup_temp_logs(logger)
        
        # ====================================================================
        # ЗАВЕРШЕНИЕ ПРОЦЕССА ОБСЛУЖИВАНИЯ
        # ====================================================================
        
        logger.info('Daily log maintenance completed successfully')
        
    except Exception as e:
        # Логируем критические ошибки и завершаем с кодом ошибки
        # Это позволяет системам мониторинга обнаружить проблемы
        logger.error(f'Error during log maintenance: {str(e)}')
        sys.exit(1)  # Код выхода 1 указывает на ошибку для систем автоматизации

# ============================================================================
# ФУНКЦИИ ОЧИСТКИ И ОБСЛУЖИВАНИЯ ФАЙЛОВ
# ============================================================================

def cleanup_temp_logs(logger):
    """
    Выполняет очистку временных файлов системы логирования.
    
    Эта функция удаляет различные типы временных файлов, которые могут
    накапливаться в процессе работы системы логирования. Включает файлы
    блокировки, временные копии и поврежденные файлы.
    
    Типы удаляемых файлов:
    - *.tmp: Временные файлы, созданные во время записи логов
    - *.lock: Файлы блокировки от прерванных операций
    - .*~: Резервные копии файлов (backup files)
    
    Безопасность:
    - Проверяет каждый файл перед удалением
    - Логирует все операции для аудита
    - Продолжает работу при ошибках удаления отдельных файлов
    - Не удаляет активные файлы логов
    
    Args:
        logger: Настроенный логгер для записи операций очистки
        
    Error Handling:
        - Обрабатывает ошибки доступа к файлам
        - Логирует предупреждения для файлов, которые не удалось удалить
        - Продолжает выполнение при частичных ошибках
        - Не прерывает процесс при проблемах с отдельными файлами
    
    Performance Notes:
        - Использует glob для эффективного поиска файлов по шаблонам
        - Минимальное влияние на производительность системы
        - Выполняется быстро благодаря простым операциям удаления
    """
    import glob  # Модуль для поиска файлов по шаблонам
    
    try:
        # Определяем шаблоны временных файлов для удаления
        # Каждый шаблон соответствует определенному типу временных файлов
        temp_patterns = [
            'logs/*.tmp',    # Временные файлы логирования
            'logs/*.lock',   # Файлы блокировки от прерванных операций
            'logs/.*~'       # Резервные копии файлов (создаются некоторыми редакторами)
        ]
        
        # Обрабатываем каждый шаблон файлов отдельно
        for pattern in temp_patterns:
            # Находим все файлы, соответствующие текущему шаблону
            temp_files = glob.glob(pattern)
            
            # Удаляем каждый найденный временный файл
            for temp_file in temp_files:
                try:
                    # Пытаемся удалить файл
                    os.remove(temp_file)
                    logger.info(f'Removed temporary file: {temp_file}')
                except Exception as e:
                    # Логируем предупреждение, но продолжаем работу
                    # Файл может быть заблокирован или недоступен
                    logger.warning(f'Could not remove temporary file {temp_file}: {str(e)}')
                    
    except Exception as e:
        # Логируем общие ошибки процесса очистки
        logger.error(f'Error during temporary file cleanup: {str(e)}')

# ============================================================================
# ФУНКЦИИ МОНИТОРИНГА И СТАТИСТИКИ
# ============================================================================

def get_log_statistics():
    """
    Собирает и возвращает подробную статистику использования системы логирования.
    
    Эта функция анализирует директорию логов и предоставляет важные метрики
    для мониторинга состояния системы логирования, планирования ресурсов
    и оптимизации процессов обслуживания.
    
    Собираемые метрики:
    - Количество активных файлов логов (неархивированных)
    - Количество архивированных файлов логов (.gz)
    - Общий размер всех файлов логов в мегабайтах
    
    Использование:
        stats = get_log_statistics()
        print(f"Active logs: {stats['active_logs']}")
        print(f"Archived logs: {stats['archived_logs']}")
        print(f"Total size: {stats['total_size_mb']} MB")
    
    Returns:
        dict: Словарь со статистикой логов:
            {
                'active_logs': int,      # Количество активных логов
                'archived_logs': int,    # Количество архивированных логов
                'total_size_mb': float   # Общий размер в мегабайтах
            }
    
    Error Handling:
        - Возвращает нулевые значения при ошибках доступа к файлам
        - Логирует ошибки в консоль для диагностики
        - Не прерывает выполнение при проблемах с отдельными файлами
        - Обрабатывает отсутствие директории логов
    
    Performance Notes:
        - Использует эффективные glob паттерны для поиска файлов
        - Минимальное использование памяти при подсчете размеров
        - Быстрое выполнение благодаря простым операциям файловой системы
    """
    import glob  # Модуль для эффективного поиска файлов по шаблонам
    
    # Инициализируем структуру статистики с нулевыми значениями
    stats = {
        'active_logs': 0,      # Счетчик активных (неархивированных) логов
        'archived_logs': 0,    # Счетчик архивированных логов
        'total_size_mb': 0     # Общий размер всех файлов логов
    }
    
    try:
        # ====================================================================
        # ПОДСЧЕТ АКТИВНЫХ ФАЙЛОВ ЛОГОВ
        # ====================================================================
        
        # Находим все файлы логов приложения (включая ротированные)
        active_logs = glob.glob('logs/app.log*')
        # Фильтруем только неархивированные файлы (исключаем .gz)
        stats['active_logs'] = len([f for f in active_logs if not f.endswith('.gz')])
        
        # ====================================================================
        # ПОДСЧЕТ АРХИВИРОВАННЫХ ФАЙЛОВ ЛОГОВ
        # ====================================================================
        
        # Находим все сжатые архивы логов
        archived_logs = glob.glob('logs/app.log*.gz')
        stats['archived_logs'] = len(archived_logs)
        
        # ====================================================================
        # РАСЧЕТ ОБЩЕГО РАЗМЕРА ФАЙЛОВ ЛОГОВ
        # ====================================================================
        
        # Находим все файлы в директории логов
        all_logs = glob.glob('logs/*')
        # Суммируем размеры только файлов (исключаем директории)
        total_size = sum(os.path.getsize(f) for f in all_logs if os.path.isfile(f))
        # Конвертируем байты в мегабайты с округлением до 2 знаков
        stats['total_size_mb'] = round(total_size / (1024 * 1024), 2)
        
    except Exception as e:
        # Выводим ошибку в консоль для диагностики
        # Не используем logger, так как функция может вызываться независимо
        print(f'Error calculating log statistics: {str(e)}')
    
    return stats

# ============================================================================
# ТОЧКА ВХОДА И УПРАВЛЕНИЕ РЕЖИМАМИ РАБОТЫ СКРИПТА
# ============================================================================

if __name__ == '__main__':
    """
    Точка входа скрипта при прямом запуске.
    
    Поддерживает два режима работы:
    1. Режим обслуживания (по умолчанию): Выполняет полный цикл обслуживания логов
    2. Режим статистики: Отображает текущую статистику использования логов
    
    Использование:
        python daily_log_maintenance.py        # Выполнить обслуживание
        python daily_log_maintenance.py stats  # Показать статистику
    
    Инициализация:
    - Автоматически создает директорию логов при необходимости
    - Проверяет аргументы командной строки для выбора режима
    - Обеспечивает корректную работу в различных окружениях
    """
    
    # ========================================================================
    # ИНИЦИАЛИЗАЦИЯ ОКРУЖЕНИЯ
    # ========================================================================
    
    # Создаем директорию для логов, если она не существует
    # exist_ok=True предотвращает ошибку при существующей директории
    os.makedirs('logs', exist_ok=True)
    
    # ========================================================================
    # ОПРЕДЕЛЕНИЕ РЕЖИМА РАБОТЫ ПО АРГУМЕНТАМ КОМАНДНОЙ СТРОКИ
    # ========================================================================
    
    # Проверяем, передан ли аргумент 'stats' для отображения статистики
    if len(sys.argv) > 1 and sys.argv[1] == 'stats':
        # ====================================================================
        # РЕЖИМ СТАТИСТИКИ: ОТОБРАЖЕНИЕ ИНФОРМАЦИИ О ЛОГАХ
        # ====================================================================
        
        # Получаем текущую статистику использования логов
        stats = get_log_statistics()
        
        # Выводим форматированную статистику в консоль
        print(f"Log Statistics:")
        print(f"Active logs: {stats['active_logs']}")
        print(f"Archived logs: {stats['archived_logs']}")
        print(f"Total size: {stats['total_size_mb']} MB")
        
    else:
        # ====================================================================
        # РЕЖИМ ОБСЛУЖИВАНИЯ: ВЫПОЛНЕНИЕ ПОЛНОГО ЦИКЛА ОБСЛУЖИВАНИЯ
        # ====================================================================
        
        # Запускаем основную функцию обслуживания логов
        # Включает архивацию, очистку и все связанные операции
        main()