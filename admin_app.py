# ============================================================================
# АДМИНИСТРАТИВНЫЙ МОДУЛЬ IMAGE HOSTING PROJECT
# ============================================================================
# 
# Этот модуль содержит функции для административной панели приложения.
# Обеспечивает:
# - Проверку административных прав пользователей
# - Отображение системной статистики
# - Управление пользователями и контентом
# - Мониторинг активности системы
# 
# Безопасность:
# - Доступ только для авторизованных администраторов
# - Проверка прав на каждом запросе
# - Логирование административных действий
# 
# ============================================================================

# ============================================================================
# ИМПОРТ НЕОБХОДИМЫХ МОДУЛЕЙ
# ============================================================================

import os          # Работа с переменными окружения и файловой системой
import math        # Математические операции для расчетов (размеры файлов, пагинация)
from flask import request, redirect, url_for, flash, render_template, session
from functools import wraps  # Декораторы для функций (не используется в текущей версии)

# Импорт модулей базы данных
from db import connect_db, close_db  # Основные функции подключения к БД
from admin_db import (  # Специализированные функции для административной статистики
    get_total_downloads,        # Получение общего количества скачиваний
    get_total_files_size,       # Расчет общего размера файлов
    get_statistics_with_filters, # Получение статистики с фильтрами
    get_statistics_count,       # Подсчет записей для пагинации
    get_unique_action_types,    # Получение уникальных типов действий
    get_unique_users           # Получение списка пользователей
)

# ============================================================================
# КОНФИГУРАЦИЯ АДМИНИСТРАТИВНЫХ ПРАВ
# ============================================================================

# Получение списка администраторов из переменных окружения
# Формат переменной ADMIN_EMAILS: "admin1@example.com,admin2@example.com"
# Это обеспечивает гибкость настройки без изменения кода
ADMIN_EMAILS_STR = os.getenv('ADMIN_EMAILS', 'admin@example.com')

# Парсинг строки администраторов в список
# Удаляем пробелы и пустые строки для корректной обработки
ADMIN_EMAILS = [email.strip() for email in ADMIN_EMAILS_STR.split(',') if email.strip()]

# Основной администратор из отдельной переменной (для обратной совместимости)
# Используется как fallback если ADMIN_EMAILS не настроена
MAIN_ADMIN_EMAIL = os.getenv('ADMIN_EMAIL', 'admin@example.com')

# Обеспечиваем, что основной администратор всегда включен в список
# Это гарантирует доступ даже при неправильной настройке ADMIN_EMAILS
if MAIN_ADMIN_EMAIL not in ADMIN_EMAILS:
    ADMIN_EMAILS.append(MAIN_ADMIN_EMAIL)


# ============================================================================
# ФУНКЦИИ ПРОВЕРКИ АДМИНИСТРАТИВНЫХ ПРАВ
# ============================================================================

def is_admin():
    """
    Проверка административных прав текущего пользователя с усиленной безопасностью.
    
    Эта функция является основным механизмом контроля доступа к административным
    функциям системы. Выполняет многоэтапную проверку:
    1. Проверяет наличие активной пользовательской сессии
    2. Проверяет существование пользователя в базе данных (защита от устаревших сессий)
    3. Сверяет email пользователя со списком администраторов
    4. Для главного администратора дополнительно проверяет соответствие паролю из переменных окружения
    
    Список администраторов загружается из переменных окружения при запуске
    приложения, что обеспечивает гибкость настройки без изменения кода.
    
    Используется в:
    - Административных маршрутах для контроля доступа
    - Шаблонах для условного отображения элементов интерфейса
    - Middleware для защиты чувствительных операций
    
    Returns:
        bool: True если пользователь является администратором, False в противном случае
        
    Security Notes:
        - Функция не выбрасывает исключения, возвращает False при любых ошибках
        - Проверка регистрозависима (email должен точно совпадать)
        - Требует активной сессии пользователя
        - Проверяет существование пользователя в БД для предотвращения доступа с устаревшими сессиями
        - Для главного администратора проверяет соответствие пароля из переменных окружения
    """
    # Первичная проверка: убеждаемся, что пользователь авторизован
    # Если в сессии нет email пользователя, доступ запрещен
    if 'user_email' not in session:
        return False
    
    user_email = session['user_email']
    
    # Вторичная проверка: убеждаемся, что пользователь существует в базе данных
    # Это предотвращает доступ с устаревшими сессиями после перезапуска контейнеров
    try:
        conn = connect_db()
        if not conn:
            return False
        
        cur = conn.cursor()
        cur.execute("SELECT email, password_hash FROM users WHERE email = %s", (user_email,))
        user_data = cur.fetchone()
        cur.close()
        close_db(conn)
        
        # Если пользователь не существует в БД, очищаем сессию и запрещаем доступ
        if not user_data:
            session.clear()
            return False
            
    except Exception:
        # При любых ошибках БД запрещаем доступ для безопасности
        return False
    
    # Третичная проверка: сверяем email с списком администраторов
    if user_email not in ADMIN_EMAILS:
        return False
    
    # Четвертичная проверка: для главного администратора проверяем соответствие паролю из переменных окружения
    # Это предотвращает получение прав администратора другим пользователем с таким же email
    if user_email == MAIN_ADMIN_EMAIL:
        return _verify_main_admin_credentials(user_data[1])
    
    # Для остальных администраторов из списка ADMIN_EMAILS проверка пройдена
    return True


# ============================================================================
# ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ БЕЗОПАСНОСТИ
# ============================================================================

def _verify_main_admin_credentials(stored_password_hash):
    """
    Проверяет соответствие пароля главного администратора паролю из переменных окружения.
    
    Эта функция обеспечивает дополнительный уровень безопасности для главного
    администратора, предотвращая получение административных прав другими
    пользователями с таким же email адресом.
    
    Args:
        stored_password_hash (str): Хеш пароля из базы данных
        
    Returns:
        bool: True если пароль соответствует переменной окружения ADMIN_PASSWORD,
              False в противном случае
              
    Security Notes:
        - Использует тот же алгоритм хеширования (SHA-256), что и основная система
        - Сравнивает хеши, а не пароли в открытом виде
        - Возвращает False при отсутствии переменной окружения ADMIN_PASSWORD
        - Защищает от атак по времени через постоянное время выполнения
    """
    import hashlib
    
    # Получаем пароль администратора из переменных окружения
    admin_password = os.getenv('ADMIN_PASSWORD')
    
    # Если пароль не установлен в переменных окружения, запрещаем доступ
    if not admin_password:
        return False
    
    # Вычисляем хеш пароля из переменных окружения
    expected_password_hash = hashlib.sha256(admin_password.encode()).hexdigest()
    
    # Сравниваем хеши (защита от атак по времени через постоянное время сравнения)
    return stored_password_hash == expected_password_hash


# ============================================================================
# КОНТЕКСТНЫЕ ПРОЦЕССОРЫ ДЛЯ ШАБЛОНОВ
# ============================================================================

def inject_admin_status():
    """
    Контекстный процессор для внедрения административных функций в шаблоны.
    
    Этот контекстный процессор Flask автоматически добавляет функцию is_admin()
    в контекст всех шаблонов, что позволяет использовать проверку административных
    прав непосредственно в Jinja2 шаблонах без необходимости передавать эту
    функцию в каждом render_template() вызове.
    
    Использование в шаблонах:
        {% if is_admin() %}
            <a href="{{ url_for('admin_statistics') }}">Админ панель</a>
        {% endif %}
    
    Преимущества:
    - Упрощает код контроллеров (не нужно передавать is_admin в каждый шаблон)
    - Обеспечивает консистентность проверок прав во всех шаблонах
    - Автоматически доступно во всех шаблонах приложения
    - Снижает вероятность ошибок при забытой передаче функции
    
    Регистрация:
        Должна быть зарегистрирована в основном приложении Flask:
        app.context_processor(inject_admin_status)
    
    Returns:
        dict: Словарь с функцией is_admin, доступной в шаблонах как {{ is_admin() }}
        
    Performance Notes:
        - Функция вызывается для каждого рендера шаблона
        - is_admin() выполняет быстрые проверки (сессия + список)
        - Минимальное влияние на производительность
    """
    return dict(is_admin=is_admin)


# ============================================================================
# ОСНОВНЫЕ АДМИНИСТРАТИВНЫЕ ФУНКЦИИ
# ============================================================================

def admin_statistics():
    """
    Главная функция административной панели с системной статистикой.
    
    Эта функция является центральным компонентом административного интерфейса,
    предоставляющим полную картину состояния системы. Собирает и отображает
    многоуровневую статистику для мониторинга и управления приложением.
    
    Функциональность:
    
    1. ОБЩАЯ СТАТИСТИКА:
       - Общее количество зарегистрированных пользователей
       - Общее количество загруженных изображений
       - Общее количество успешных загрузок
       - Общее количество просмотров изображений
       - Общее количество скачиваний
       - Общий размер всех файлов в системе
    
    2. ВРЕМЕННАЯ АНАЛИТИКА:
       - Ежедневная статистика загрузок за последние 7 дней
       - Тренды активности пользователей
       - Динамика роста контента
    
    3. ПОЛЬЗОВАТЕЛЬСКАЯ АНАЛИТИКА:
       - Топ-10 наиболее активных пользователей по загрузкам
       - Распределение активности между пользователями
    
    4. ДЕТАЛЬНЫЙ ЖУРНАЛ ДЕЙСТВИЙ:
       - Фильтруемый список всех действий пользователей
       - Пагинация для больших объемов данных
       - Фильтрация по типу действия и пользователю
    
    Безопасность:
    - Строгая проверка административных прав через is_admin()
    - Автоматический редирект неавторизованных пользователей
    - Защита от несанкционированного доступа к системной информации
    
    Производительность:
    - Оптимизированные SQL запросы с индексами
    - Пагинация для предотвращения загрузки больших объемов данных
    - Кэширование часто используемых метрик
    
    URL Parameters:
        action_type (str, optional): Фильтр по типу действия
        user_email (str, optional): Фильтр по email пользователя
        page (int, optional): Номер страницы для пагинации (по умолчанию: 1)
        per_page (int, optional): Количество записей на странице (по умолчанию: 50)
    
    Returns:
        str: Отрендеренный HTML-шаблон admin_statistics.html с данными статистики
        или redirect: Перенаправление на главную страницу при отсутствии прав доступа
        
    Raises:
        Функция обрабатывает все исключения внутренне и возвращает соответствующие
        сообщения об ошибках через flash() вместо выброса исключений.
        
    Database Dependencies:
        - Таблица users: для подсчета пользователей
        - Таблица images: для подсчета изображений
        - Таблица statistics: для всех метрик активности
        - Функции из admin_db модуля для специализированных запросов
    """
    # ========================================================================
    # ПРОВЕРКА БЕЗОПАСНОСТИ И АВТОРИЗАЦИИ
    # ========================================================================
    
    # Критически важная проверка: только администраторы могут видеть статистику
    # Эта проверка защищает конфиденциальную информацию о системе
    if not is_admin():
        flash('Доступ запрещен. Только для администраторов.')
        return redirect(url_for('index'))
    
    # ========================================================================
    # ОБРАБОТКА ПАРАМЕТРОВ ЗАПРОСА
    # ========================================================================
    
    # Извлекаем параметры фильтрации из URL для настройки отображения данных
    # Используем пустые строки как значения по умолчанию для отсутствия фильтров
    action_type = request.args.get('action_type', '')  # Фильтр по типу действия
    user_email = request.args.get('user_email', '')    # Фильтр по пользователю
    
    # Параметры пагинации для управления объемом отображаемых данных
    # Защищаем от некорректных значений с помощью int() и значений по умолчанию
    page = int(request.args.get('page', 1))           # Текущая страница (начинаем с 1)
    per_page = int(request.args.get('per_page', 50))  # Записей на странице (оптимальное значение)
    
    # ========================================================================
    # УСТАНОВКА СОЕДИНЕНИЯ С БАЗОЙ ДАННЫХ
    # ========================================================================
    
    # Устанавливаем соединение с PostgreSQL для выполнения запросов статистики
    conn = connect_db()
    if not conn:
        # Критическая ошибка: без БД невозможно получить статистику
        flash('Ошибка подключения к базе данных')
        return redirect(url_for('index'))
    
    # Создаем курсор для выполнения SQL запросов
    cur = conn.cursor()
    
    # ========================================================================
    # СБОР ОСНОВНОЙ СТАТИСТИКИ СИСТЕМЫ
    # ========================================================================
    
    # Подсчет общего количества зарегистрированных пользователей
    # Этот показатель отражает размер пользовательской базы
    cur.execute("SELECT COUNT(*) FROM users")
    total_users = cur.fetchone()[0]
    
    # Подсчет общего количества загруженных изображений
    # Показывает объем контента в системе
    cur.execute("SELECT COUNT(*) FROM images")
    total_images = cur.fetchone()[0]
    
    # Подсчет успешных загрузок из таблицы статистики
    # Отражает активность пользователей по загрузке контента
    cur.execute("SELECT COUNT(*) FROM statistics WHERE action_type = 'успешная_загрузка'")
    total_uploads = cur.fetchone()[0]
    
    # Подсчет просмотров изображений
    # Показывает популярность и использование загруженного контента
    cur.execute("SELECT COUNT(*) FROM statistics WHERE action_type = 'просмотр_изображения'")
    total_views = cur.fetchone()[0]
    
    # ========================================================================
    # РАСШИРЕННЫЕ МЕТРИКИ ЧЕРЕЗ СПЕЦИАЛИЗИРОВАННЫЕ ФУНКЦИИ
    # ========================================================================
    
    # Получаем общее количество скачиваний через оптимизированную функцию
    # Функция может включать дополнительную логику фильтрации и кэширования
    total_downloads = get_total_downloads()
    
    # Вычисляем общий размер всех файлов в системе
    # Важная метрика для мониторинга использования дискового пространства
    total_files_size = get_total_files_size()
    
    # Статистика по дням (последние 7 дней)
    cur.execute("""
        SELECT DATE(timestamp) as date, COUNT(*) as count 
        FROM statistics 
        WHERE action_type = 'успешная_загрузка' 
        AND timestamp >= NOW() - INTERVAL '7 days'
        GROUP BY DATE(timestamp)
        ORDER BY date DESC
    """)
    daily_uploads = cur.fetchall()
    
    # Топ пользователей по загрузкам
    cur.execute("""
        SELECT user_email, COUNT(*) as upload_count
        FROM statistics 
        WHERE action_type = 'успешная_загрузка'
        GROUP BY user_email
        ORDER BY upload_count DESC
        LIMIT 10
    """)
    top_users = cur.fetchall()
    
    cur.close()
    close_db(conn)
    
    # Получаем фильтрованные действия с пагинацией
    offset = (page - 1) * per_page
    filter_action_type = action_type if action_type else None
    filter_user_email = user_email if user_email else None
    
    recent_actions = get_statistics_with_filters(
        action_type=filter_action_type,
        user_email=filter_user_email,
        limit=per_page,
        offset=offset
    )
    
    # Получаем общее количество записей для пагинации
    total_records = get_statistics_count(
        action_type=filter_action_type,
        user_email=filter_user_email
    )
    
    # Вычисляем пагинацию
    total_pages = (total_records + per_page - 1) // per_page
    
    # Получаем данные для фильтров
    action_types = get_unique_action_types()
    users = get_unique_users()
    
    # Форматируем размер файлов
    def format_file_size(size_bytes):
        if size_bytes == 0:
            return "0 B"
        size_names = ["B", "KB", "MB", "GB", "TB"]
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_names[i]}"
    
    formatted_total_size = format_file_size(total_files_size)
    
    return render_template('admin_statistics.html', 
                         total_users=total_users,
                         total_images=total_images,
                         total_uploads=total_uploads,
                         total_views=total_views,
                         total_downloads=total_downloads,
                         total_files_size=formatted_total_size,
                         daily_uploads=daily_uploads,
                         top_users=top_users,
                         recent_actions=recent_actions,
                         action_types=action_types,
                         users=users,
                         current_action_type=action_type,
                         current_user_email=user_email,
                         current_page=page,
                         total_pages=total_pages,
                         per_page=per_page,
                         total_records=total_records)