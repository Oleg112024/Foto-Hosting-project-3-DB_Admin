# -*- coding: utf-8 -*-
"""
Модуль конфигурации системы логирования для Image Hosting Project.

Этот модуль обеспечивает:
- Настройку ротации логов по времени (ежедневно)
- Автоматическое архивирование старых логов
- Очистку устаревших архивов
- Форматирование сообщений с временными метками
- Вывод логов в файл и консоль

Автор: Image Hosting Project
Версия: 2.0
"""

# ============================================================================
# ИМПОРТЫ И ЗАВИСИМОСТИ
# ============================================================================

import logging                # Основная библиотека логирования
import logging.handlers       # Обработчики с ротацией
import os                     # Работа с файловой системой
from datetime import datetime # Работа с датой и временем

# ============================================================================
# ИНИЦИАЛИЗАЦИЯ ДИРЕКТОРИЙ
# ============================================================================

# Создаем директорию для логов, если она не существует
# exist_ok=True предотвращает ошибку при существующей директории
os.makedirs('logs', exist_ok=True)

# ============================================================================
# ОСНОВНЫЕ ФУНКЦИИ КОНФИГУРАЦИИ
# ============================================================================

def setup_logging():
    """
    Настройка системы логирования с автоматической ротацией файлов.
    
    Функция создает и настраивает логгер с двумя обработчиками:
    1. TimedRotatingFileHandler - для записи в файлы с ежедневной ротацией
    2. StreamHandler - для вывода в консоль
    
    Особенности:
    - Ротация происходит каждый день в полночь
    - Хранятся логи за последние 30 дней
    - Используется UTF-8 кодировка для поддержки русского языка
    - Единый формат сообщений с временными метками
    
    Returns:
        logging.Logger: Настроенный логгер
        
    Note:
        Функция очищает существующие обработчики для предотвращения дублирования
    """
    
    # Получаем корневой логгер приложения
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)  # Уровень логирования: INFO и выше
    
    # Очищаем существующие обработчики для предотвращения дублирования
    # Важно при повторных вызовах функции
    logger.handlers.clear()
    
    # ========================================================================
    # НАСТРОЙКА ФОРМАТИРОВАНИЯ СООБЩЕНИЙ
    # ========================================================================
    
    # Создаем форматтер для единообразного вида сообщений
    log_formatter = logging.Formatter(
        '[%(asctime)s] %(levelname)s: %(message)s',  # Формат: [время] уровень: сообщение
        datefmt='%Y-%m-%d %H:%M:%S'                  # Формат времени: ГГГГ-ММ-ДД ЧЧ:ММ:СС
    )
    
    # ========================================================================
    # НАСТРОЙКА ФАЙЛОВОГО ОБРАБОТЧИКА С РОТАЦИЕЙ
    # ========================================================================
    
    # Обработчик для автоматической ротации логов по времени
    time_handler = logging.handlers.TimedRotatingFileHandler(
        filename='logs/app.log',    # Основной файл логов
        when='midnight',            # Ротация в полночь
        interval=1,                 # Каждый день
        backupCount=30,             # Храним логи за 30 дней
        encoding='utf-8'            # UTF-8 для поддержки русского языка
    )
    time_handler.setFormatter(log_formatter)
    time_handler.suffix = '%Y-%m-%d'  # Суффикс для архивных файлов: app.log.2025-01-15
    
    # ========================================================================
    # НАСТРОЙКА КОНСОЛЬНОГО ОБРАБОТЧИКА
    # ========================================================================
    
    # Обработчик для вывода логов в консоль (для разработки и отладки)
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(log_formatter)
    
    # ========================================================================
    # РЕГИСТРАЦИЯ ОБРАБОТЧИКОВ
    # ========================================================================
    
    # Добавляем оба обработчика к логгеру
    logger.addHandler(time_handler)    # Запись в файлы
    logger.addHandler(console_handler) # Вывод в консоль
    
    return logger

def setup_monthly_archive():
    """
    Настройка автоматической архивации старых файлов логов.
    
    Функция выполняет сжатие файлов логов старше 30 дней для экономии
    дискового пространства. Архивирование происходит с использованием
    gzip сжатия, что значительно уменьшает размер файлов.
    
    Алгоритм работы:
    1. Поиск всех файлов логов в директории logs/
    2. Извлечение даты из имени файла (формат: app.log.YYYY-MM-DD)
    3. Проверка возраста файла (старше 30 дней)
    4. Сжатие файла в gzip архив
    5. Удаление оригинального файла
    
    Note:
        Функция безопасна - обрабатывает ошибки и логирует результаты
    """
    import gzip  # Библиотека для сжатия файлов
    import glob  # Поиск файлов по шаблону
    from datetime import datetime, timedelta
    
    # Получаем текущую дату для сравнения
    current_date = datetime.now()
    
    # Поиск всех файлов логов по шаблону
    # Шаблон: logs/app.log.YYYY-MM-DD
    log_pattern = 'logs/app.log.*'
    log_files = glob.glob(log_pattern)
    
    # Обработка каждого найденного файла лога
    for log_file in log_files:
        try:
            # Извлечение даты из имени файла
            # Пример: logs/app.log.2025-01-15 -> 2025-01-15
            file_date_str = log_file.split('.')[-1]
            
            # Проверка корректности формата даты (YYYY-MM-DD = 10 символов)
            if len(file_date_str) == 10:
                file_date = datetime.strptime(file_date_str, '%Y-%m-%d')
                
                # Проверка возраста файла (старше 30 дней)
                if (current_date - file_date).days > 30:
                    archive_file = f"{log_file}.gz"  # Имя архивного файла
                    
                    # Сжатие файла в gzip архив
                    with open(log_file, 'rb') as f_in:        # Открываем исходный файл
                        with gzip.open(archive_file, 'wb') as f_out:  # Создаем gzip архив
                            f_out.writelines(f_in)            # Копируем содержимое
                    
                    # Удаление оригинального файла после успешного архивирования
                    os.remove(log_file)
                    logging.info(f'Archived log file: {log_file} -> {archive_file}')
                    
        except Exception as e:
            # Логирование ошибок без прерывания процесса
            logging.error(f'Error archiving log file {log_file}: {str(e)}')

def cleanup_old_archives():
    """
    Удаление архивных файлов логов старше 12 месяцев.
    
    Функция выполняет финальную очистку дискового пространства,
    удаляя сжатые архивы логов, которые хранятся дольше года.
    Это предотвращает бесконечное накопление архивных файлов.
    
    Алгоритм работы:
    1. Поиск всех gzip архивов логов
    2. Извлечение даты из имени архива
    3. Проверка возраста архива (старше 365 дней)
    4. Удаление устаревших архивов
    
    Note:
        Функция безопасна - обрабатывает ошибки и логирует результаты
    """
    import glob  # Поиск файлов по шаблону
    from datetime import datetime, timedelta
    
    # Получаем текущую дату для сравнения
    current_date = datetime.now()
    
    # Поиск всех архивных файлов по шаблону
    # Шаблон: logs/app.log.YYYY-MM-DD.gz
    archive_pattern = 'logs/app.log.*.gz'
    archive_files = glob.glob(archive_pattern)
    
    # Обработка каждого найденного архива
    for archive_file in archive_files:
        try:
            # Извлечение даты из имени архива
            # Пример: logs/app.log.2025-01-15.gz -> 2025-01-15
            file_date_str = archive_file.split('.')[-2]  # Убираем расширение .gz
            
            # Проверка корректности формата даты (YYYY-MM-DD = 10 символов)
            if len(file_date_str) == 10:
                file_date = datetime.strptime(file_date_str, '%Y-%m-%d')
                
                # Проверка возраста архива (старше 12 месяцев = 365 дней)
                if (current_date - file_date).days > 365:
                    os.remove(archive_file)  # Удаление устаревшего архива
                    logging.info(f'Removed old archive: {archive_file}')
                    
        except Exception as e:
            # Логирование ошибок без прерывания процесса
            logging.error(f'Error removing old archive {archive_file}: {str(e)}')